The first thing I noticed in unrefactored code was the global `docs_memory` list and the inline Qdrant initialization. These created hidden dependencies that would make unit testing challenging. My main decision was to invert the control: instead of functions grabbing what they need from global scope, I made every component receive its dependencies through the constructor. This led me to a four-layer architecture (`domain/`, `infrastructure/`, `application/`, `api/`) to enforce a strict policy where dependencies point only in one direction. The `domain/` layer contains only Python abstract base classes with no external imports, ensuring it remains stable as the innermost layer. Concrete implementations in `infrastructure/` import from `domain/` but never the reverse. The `application/` layer houses `RAGEngine` which coordinates between embedding and storage without knowing their concrete types.

The main trade-off of adopting this four-layer architecture is the increased verbosity and separation, which can seem like over-engineering for a relatively small application. For example, a simple change might require updates across multiple files (interface, implementation, and wiring) rather than just editing a single function in `main.py`. However, I chose to accept this complexity cost to gain rigid separation of concerns. This structure ensures that business logic in the `application` layer remains completely isolated from technical details like which database or database driver is being used, making the system significantly more robust to future technology changes.

The refactored code improves maintainability by localizing change impact. HTTP schema changes stay in `api/schemas.py` without affecting business logic. New storage backends only require implementing the five abstract members of `DocumentStore`. The `RAGEngine` can be instantiated in tests with mock dependencies passed directly to its constructor, eliminating the need for patching or environment manipulation. Each module has a single reason to change, which reduces merge conflicts in team development and makes code reviews more focused.
